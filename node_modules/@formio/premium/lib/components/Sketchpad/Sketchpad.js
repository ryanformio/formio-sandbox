var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { Formio, Components, Utils } from 'formiojs';
import Two from 'two.js';
import Picker from 'vanilla-picker';
import editForm from './Sketchpad.form';
import getModes from './Sketchpad.modes';
import toolbarButtons from './Sketchpad.toolbar.buttons';
var FieldComponent = Components.components.field;
var Sketchpad = /** @class */ (function (_super) {
    __extends(Sketchpad, _super);
    function Sketchpad() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.apply(this, args) || this;
        _this.dimensionsCorrection = 1;
        _this.imageType = _this.component.imageType;
        _this.modes = getModes.call(_this, Two);
        _this.state = {
            mode: Object.keys(_this.modes)[0],
            stroke: _this.component.defaultStroke || Sketchpad.defaultStroke,
            fill: _this.component.defaultFill || Sketchpad.defaultFill,
            linewidth: _this.component.defaultLineWidth || Sketchpad.defaultLineWidth,
            circleSize: _this.component.defaultCircleSize || Sketchpad.defaultCircleSize,
        };
        _this.dimensionsMultiplier = 1;
        _this.zoomInfo = {
            viewBox: {},
            canvasViewBox: {},
            multiplier: 1.5,
            totalMultiplier: 1,
        };
        _this.deleted = [];
        _this.layers = [];
        return _this;
    }
    Object.defineProperty(Sketchpad, "defaultFill", {
        get: function () {
            return '#ccc';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad, "defaultStroke", {
        get: function () {
            return '#333';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad, "defaultLineWidth", {
        get: function () {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad, "defaultCircleSize", {
        get: function () {
            return 10;
        },
        enumerable: false,
        configurable: true
    });
    Sketchpad.schema = function () {
        var extend = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            extend[_i] = arguments[_i];
        }
        return FieldComponent.schema.apply(FieldComponent, __spreadArrays([{
                type: 'sketchpad',
                label: 'Sketchpad',
                key: 'sketchpad',
                input: true,
                multiple: true,
                modalEdit: true,
                imageType: 'image',
                autoSize: true,
                defaultZoom: 100,
                defaultStroke: Sketchpad.defaultStroke,
                defaultFill: Sketchpad.defaultFill,
                defaultLineWidth: Sketchpad.defaultLineWidth,
                defaultCircleSize: Sketchpad.defaultCircleSize,
            }], extend));
    };
    Object.defineProperty(Sketchpad, "builderInfo", {
        get: function () {
            return {
                title: 'Sketchpad',
                group: 'premium',
                icon: 'image',
                weight: 110,
                documentation: '/userguide/forms/premium-components#sketchpad',
                schema: Sketchpad.schema(),
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad, "simpleConditionSettings", {
        get: function () {
            return __assign(__assign({}, _super.simpleConditionSettings), { operators: ['isEmpty', 'isNotEmpty'] });
        },
        enumerable: false,
        configurable: true
    });
    Sketchpad.prototype.render = function () {
        return _super.prototype.render.call(this, this.renderTemplate(this.templateName, __assign({}, this.renderContext)));
    };
    Sketchpad.prototype.loadComponentRefs = function (element) {
        this.loadRefs(element, __assign({ canvas: 'single', drawingContainer: 'single', background: 'single', backgroundImage: 'single', totalMultiplier: 'single', previewContainer: 'single', previewDrawing: 'single', previewBackground: 'single' }, this.buttonsRefs));
    };
    Sketchpad.prototype.init = function () {
        var _this = this;
        var backgroundReadyPromise = new Formio.Promise(function (resolve, reject) {
            _this.backgroundReady = { resolve: resolve, reject: reject };
        });
        this.backgroundReady.promise = backgroundReadyPromise;
        return _super.prototype.init.call(this);
    };
    Sketchpad.prototype.attach = function (element) {
        var _this = this;
        var backgroundReadyPromise = new Formio.Promise(function (resolve, reject) {
            _this.backgroundReady = { resolve: resolve, reject: reject };
        });
        this.backgroundReady.promise = backgroundReadyPromise;
        var superAttach = _super.prototype.attach.call(this, element);
        this.loadComponentRefs(element);
        if (this.refs.canvas) {
            this.createDrawingArea();
            this.backgroundReady.promise.then(function () { return _this.onBackgroundReady(); });
            if (!this.disabled && !this.shouldDisabled && !this.readOnly) {
                this.attachDrawEvents();
            }
            if (this.imageType === 'image' && this.refs.backgroundImage) {
                this.loadBackgroundImage(this.refs.backgroundImage);
            }
            else {
                this.addBackground();
            }
            this.attachToolbar();
        }
        return superAttach;
    };
    Object.defineProperty(Sketchpad.prototype, "buttonsRefs", {
        get: function () {
            var refsConfig = {};
            Object.values(toolbarButtons).forEach(function (buttonsGroup) { return buttonsGroup.forEach(function (button) {
                refsConfig[button.key] = 'single';
                if (button.input) {
                    refsConfig[button.key + "-input"] = 'single';
                }
            }); });
            return refsConfig;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "renderContext", {
        get: function () {
            return {
                zoomInfo: {
                    totalMultiplier: this.zoomInfo ? Math.round(this.zoomInfo.totalMultiplier * 100) / 100 : 1,
                },
                buttonGroups: this.buttonGroups,
                disabled: _super.prototype.disabled,
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "defaultSchema", {
        get: function () {
            return Sketchpad.schema();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "templateName", {
        get: function () {
            return 'sketchpad';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "emptyValue", {
        get: function () {
            return [];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "dataReady", {
        get: function () {
            return this.backgroundReady.promise;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "attachFunctions", {
        get: function () {
            var _this = this;
            var setColor = function (element, color, onChange) {
                var picker = new Picker(element);
                element.style.color = color;
                picker.setColor(color, true);
                picker.onChange = function (newColor) {
                    element.style.color = newColor.rgbaString;
                    onChange(newColor.rgbaString);
                };
                return element;
            };
            var attachInput = function (key, value, onChange) {
                var inputRef = _this.refs[key];
                if (inputRef) {
                    inputRef.addEventListener('change', function (e) { return onChange(e.target.value); });
                    inputRef.value = value;
                }
            };
            return {
                stroke: function (element) { return setColor(element, _this.state.stroke, function (color) { return _this.state.stroke = color; }); },
                fill: function (element) { return setColor(element, _this.state.fill, function (color) { return _this.state.fill = color; }); },
                width: function () { return attachInput('width-input', _this.state.linewidth, function (lineWidth) { return _this.state.linewidth = +lineWidth; }); },
                circle: function () { return attachInput('circle-input', _this.state.circleSize, function (circleSize) { return _this.state.circleSize = +circleSize; }); },
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "buttonGroups", {
        get: function () {
            return Object.entries(toolbarButtons).map(function (_a) {
                var buttons = _a[1];
                return buttons;
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "componentLabel", {
        get: function () {
            return "" + (this.component.hideLabel ? '' : "<label class=\"control-label\">" + this.component.label + "</label><br>");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "viewBoxFromSubmission", {
        /**
         * ViewBox taken from the submission
         * Required to display the drawing from submission properly if the screen size has changed
         */
        get: function () {
            return this._viewBoxFromSubmission;
        },
        set: function (value) {
            this._viewBoxFromSubmission = value;
            var width = value.width, height = value.height, minX = value.minX, minY = value.minY;
            if (this.backgroundReady.isReady) {
                this.setCanvasViewBox(width, height, minX, minY);
            }
        },
        enumerable: false,
        configurable: true
    });
    Sketchpad.prototype.loadBackgroundImage = function (backgrounImageElement) {
        var _this = this;
        backgrounImageElement.addEventListener('load', function () { return _this.addBackground(); });
        backgrounImageElement.setAttribute('src', this.component.imageUrl);
    };
    Sketchpad.prototype.createDrawingArea = function () {
        this.two = new Two({ type: Two.Types.svg }).appendTo(this.refs.canvas);
        this.canvasSvg = this.two.renderer.domElement;
        this.addClass(this.canvasSvg, 'formio-sketchpad-svg');
        this.canvasSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    };
    Sketchpad.prototype.getActualCoordinate = function (coordinate) {
        // recalculate coordinate taking into account changed size of drawing area
        var x = coordinate.x, y = coordinate.y;
        var minX = this.zoomInfo.canvasViewBox.current.minX;
        var minY = this.zoomInfo.canvasViewBox.current.minY;
        coordinate.x = Math.round(x / this.zoomInfo.totalMultiplier / this.dimensionsMultiplier + minX);
        coordinate.y = Math.round(y / this.zoomInfo.totalMultiplier / this.dimensionsMultiplier + minY);
        return coordinate;
    };
    Sketchpad.prototype.onBackgroundReady = function () {
        var _this = this;
        this.backgroundReady.isReady = true;
        this.addEventListener(window, 'resize', Utils._.debounce(function () { return _this.stretchDrawingArea(); }, 100));
        this.resetZoom(); // set zoom to default
    };
    Sketchpad.prototype.addBackground = function () {
        var _this = this;
        if (this.refs.backgroundImage && this.refs.backgroundImage.complete) {
            this.setBackgroundImage();
        }
        else if (this.component.imageUrl && this.imageType === 'svg') {
            Formio.makeStaticRequest(this.component.imageUrl, 'GET', null, { noToken: true, headers: {} })
                .then(function (image) {
                _this.setBackgroundImage(image);
            })
                .catch(function (err) {
                /* tslint:disable */
                console.warn(err);
                /* tslint:enable */
                _this.refs.background.innerHTML = _this.t('Background image failed to load. Tagpad doesn\'t work without background image');
                _this.backgroundReady.reject();
            });
        }
    };
    Sketchpad.prototype.parseSvg = function (svgMarkup) {
        var xmlDoc = new DOMParser().parseFromString(svgMarkup, 'image/svg+xml');
        var backgroundSvg = xmlDoc.getElementsByTagName('svg');
        if (!backgroundSvg || !backgroundSvg[0]) {
            return null;
        }
        return backgroundSvg[0];
    };
    Sketchpad.prototype.prepareSvg = function (svg) {
        // make background image to be stretched to available width and preserve aspect ratio
        svg.removeAttribute('width');
        svg.removeAttribute('height');
        svg.setAttribute('ref', 'backgroundImage');
    };
    Sketchpad.prototype.setSvgImage = function (svgMarkup) {
        var backgroundSvg = this.parseSvg(svgMarkup);
        if (!backgroundSvg) {
            /* tslint:disable */
            console.warn("Sketchpad '" + this.component.key + "': Background SVG doesn't contain <svg> tag on it");
            /* tslint:enable */
            return;
        }
        // read initial dimensions from viewBox
        var initialViewBox = backgroundSvg.getAttribute('viewBox');
        var dimensions = initialViewBox ? initialViewBox.split(' ').map(parseFloat)
            : this.mapDimensionsFromAttributes(backgroundSvg);
        this.setDimensions.apply(this, dimensions);
        this.prepareSvg(backgroundSvg);
        var viewBox = this.dimensions;
        this.assignZoomInfo(viewBox);
        this.setViewBoxAttribute(backgroundSvg, viewBox);
        svgMarkup = new XMLSerializer().serializeToString(backgroundSvg);
        // fix issue in Chrome when it returned '<svg:svg>...</svg:svg>' string after serialization
        svgMarkup = svgMarkup.replace('<svg:svg', '<svg').replace('</svg:svg>', '</svg>');
        this.loadComponentRefs(this.element);
        this.refs.background.innerHTML = svgMarkup;
    };
    Sketchpad.prototype.assignZoomInfo = function (viewBox, type) {
        if (type === void 0) { type = 'viewBox'; }
        this.zoomInfo[type].default = {
            width: viewBox.width,
            height: viewBox.height,
            minX: viewBox.minX,
            minY: viewBox.minY,
        };
        // Save the viewBox to hte state to make it persistent within the submission
        this.state.viewBox = this.zoomInfo[type].default;
        this.zoomInfo[type].current = Utils._.cloneDeep(this.zoomInfo[type].default);
    };
    Sketchpad.prototype.buttonAttributes = function (button) {
        return (button && button.input && button.input.attributes) ?
            Object.entries(button.input.attributes).map(function (_a) {
                var attr = _a[0], value = _a[1];
                return attr + "='" + value + "'";
            }).join(' ') :
            '';
    };
    Sketchpad.prototype.attachDrawEvents = function () {
        var _this = this;
        this.canvasSvg
            .addEventListener('mousedown', function (e) {
            e.preventDefault();
            var offset = _this.canvasSvg.getBoundingClientRect();
            // change cursor
            var cursor = 'default';
            if (_this.modes[_this.state.mode].cursor) {
                cursor = _this.modes[_this.state.mode].cursor.clicked || _this.modes[_this.state.mode].cursor.hover;
            }
            _this.canvasSvg.style.cursor = cursor;
            if (_this.modes[_this.state.mode].eventStart) {
                _this.modes[_this.state.mode].eventStart(_this.getActualCoordinate({
                    x: e.clientX - offset.left,
                    y: e.clientY - offset.top,
                }));
            }
            var mouseDrag = function (e) {
                e.preventDefault();
                var offset = _this.canvasSvg.getBoundingClientRect();
                if (_this.modes[_this.state.mode].drag) {
                    _this.modes[_this.state.mode].drag(_this.getActualCoordinate({
                        x: e.clientX - offset.left,
                        y: e.clientY - offset.top,
                    }));
                }
            };
            var mouseEnd = function (e) {
                e.preventDefault();
                _this.canvasSvg.removeEventListener('mousemove', mouseDrag);
                _this.canvasSvg.removeEventListener('mouseup', mouseEnd);
                document.removeEventListener('mouseup', mouseEnd);
                // change cursor
                var cursor = 'default';
                if (_this.modes[_this.state.mode].cursor) {
                    cursor = _this.modes[_this.state.mode].cursor.hover || cursor;
                }
                _this.canvasSvg.style.cursor = cursor;
                var offset = _this.canvasSvg.getBoundingClientRect();
                if (_this.modes[_this.state.mode].eventEnd) {
                    _this.modes[_this.state.mode].eventEnd(_this.getActualCoordinate({
                        x: e.clientX - offset.left,
                        y: e.clientY - offset.top,
                    }));
                }
            };
            _this.canvasSvg.addEventListener('mousemove', mouseDrag);
            _this.canvasSvg.addEventListener('mouseup', mouseEnd);
            // this is necessary to stop drawing after mouse is up outside of canvas
            document.addEventListener('mouseup', mouseEnd);
            return false;
        });
        // Set up touch events.
        this.canvasSvg
            .addEventListener('touchstart', function (e) {
            e.preventDefault();
            var offset = _this.canvasSvg.getBoundingClientRect();
            var touch = e.changedTouches[0];
            // change cursor
            var cursor = 'default';
            if (_this.modes[_this.state.mode].cursor) {
                cursor = _this.modes[_this.state.mode].cursor.clicked || _this.modes[_this.state.mode].cursor.hover;
            }
            _this.canvasSvg.style.cursor = cursor;
            if (_this.modes[_this.state.mode].eventStart) {
                _this.modes[_this.state.mode].eventStart(_this.getActualCoordinate({
                    x: touch.clientX - offset.left,
                    y: touch.clientY - offset.top,
                }));
            }
            var touchDrag = function (e) {
                e.preventDefault();
                var offset = _this.canvasSvg.getBoundingClientRect();
                var touch = e.changedTouches[0];
                if (_this.modes[_this.state.mode].drag) {
                    _this.modes[_this.state.mode].drag(_this.getActualCoordinate({
                        x: touch.clientX - offset.left,
                        y: touch.clientY - offset.top,
                    }));
                }
            };
            var touchEnd = function (e) {
                e.preventDefault();
                _this.canvasSvg
                    .removeEventListener('touchmove', touchDrag);
                _this.canvasSvg
                    .removeEventListener('touchend', touchEnd);
                var offset = _this.canvasSvg.getBoundingClientRect();
                var touch = e.changedTouches[0];
                // change cursor
                var cursor = 'default';
                if (_this.modes[_this.state.mode].cursor) {
                    cursor = _this.modes[_this.state.mode].cursor.hover || cursor;
                }
                _this.canvasSvg.style.cursor = cursor;
                if (_this.modes[_this.state.mode].eventEnd) {
                    _this.modes[_this.state.mode].eventEnd(_this.getActualCoordinate({
                        x: touch.clientX - offset.left,
                        y: touch.clientY - offset.top,
                    }));
                }
            };
            _this.canvasSvg
                .addEventListener('touchmove', touchDrag);
            _this.canvasSvg
                .addEventListener('touchend', touchEnd);
            return false;
        });
        this.two.update();
    };
    Sketchpad.prototype.attachToolbar = function () {
        this.attachModesButtons();
        this.attachStylesButtons();
        this.attachActionsButtons();
        this.setActiveButton(this.state.mode);
    };
    Sketchpad.prototype.attachModesButtons = function () {
        var _this = this;
        toolbarButtons.modes.forEach(function (mode) {
            var buttonRef = _this.refs[mode.key];
            if (buttonRef && _this.modes[mode.key]) {
                var modeConfig_1 = _this.modes[mode.key];
                buttonRef.addEventListener('click', function (e) { return _this.setState(modeConfig_1.state); });
                _this.callAttachFunction(buttonRef, mode.key);
            }
        });
    };
    Sketchpad.prototype.attachStylesButtons = function () {
        var _this = this;
        toolbarButtons.styles.forEach(function (style) {
            var buttonRef = _this.refs[style.key];
            if (buttonRef) {
                _this.callAttachFunction(buttonRef, style.key);
            }
        });
    };
    Sketchpad.prototype.attachActionsButtons = function () {
        var _this = this;
        toolbarButtons.actions.forEach(function (action) {
            var buttonRef = _this.refs[action.key];
            if (buttonRef) {
                buttonRef.addEventListener('click', function () { return _this[action.key](); });
            }
        });
    };
    Sketchpad.prototype.callAttachFunction = function (element, key) {
        if (this.attachFunctions[key]) {
            this.attachFunctions[key](element);
        }
    };
    Sketchpad.prototype.setState = function (state) {
        Object.assign(this.state, state);
        this.setActiveButton(this.state.mode);
        this.canvasSvg.style.cursor = Utils._.get(this.modes[this.state.mode], 'cursor.hover', 'default');
    };
    Sketchpad.prototype.setActiveButton = function (mode) {
        var _this = this;
        toolbarButtons.modes.forEach(function (modeButton) {
            if (_this.refs[modeButton.key]) {
                _this.removeClass(_this.refs[modeButton.key], 'active');
            }
            if (_this.refs[mode]) {
                _this.addClass(_this.refs[mode], 'active');
            }
        });
    };
    Sketchpad.prototype.setBackgroundImage = function (image) {
        if (this.imageType === 'svg') {
            if (image && image.startsWith('<?xml')) {
                this.setSvgImage(image);
            }
            else { // Fallback to the 'image', after the image is loaded, this method will be called again
                this.imageType = 'image';
                var background = new Image();
                background.setAttribute('ref', 'backgroundImage');
                this.refs.background.appendChild(background);
                this.loadBackgroundImage(background);
            }
        }
        else {
            this.setRasterImage();
        }
        this.onBackgroundImageWasSetted();
    };
    Sketchpad.prototype.setRasterImage = function () {
        var viewBoxWidth = this.refs.backgroundImage.naturalWidth;
        var viewBoxHeight = this.refs.backgroundImage.naturalHeight;
        this.setDimensions(0, 0, viewBoxWidth, viewBoxHeight);
        this.assignZoomInfo(this.dimensions);
    };
    Sketchpad.prototype.setCanvasViewBox = function (width, height, minX, minY) {
        var _a, _b;
        if (minX === void 0) { minX = 0; }
        if (minY === void 0) { minY = 0; }
        this.setDimensions(minX, minY, width, height);
        this.assignZoomInfo(this.dimensions, 'canvasViewBox');
        if ((_b = (_a = this.zoomInfo) === null || _a === void 0 ? void 0 : _a.viewBox) === null || _b === void 0 ? void 0 : _b.default) {
            this.dimensionsCorrection = this.dimensions.width / this.zoomInfo.viewBox.default.width;
        }
        else {
            // tslint:disable-next-line:no-console
            console.warn('Default ViewBox is not defined');
        }
        // set canvas image viewBox (necessary for canvas SVG to stretch properly without losing correct aspect ration)
        this.setViewBoxAttribute(this.canvasSvg, this.zoomInfo.canvasViewBox.default);
        this.setEditorSize(this.dimensions.width, this.dimensions.height);
        this.stretchDrawingArea();
    };
    Sketchpad.prototype.calculateCanvasViewBox = function () {
        var width = this.component.width;
        var height = this.component.height;
        if (this.component.autoSize) {
            var calculatedSize = this.calculateAutoSize();
            width = calculatedSize.width;
            height = calculatedSize.height;
        }
        if (width && height && !this.component.autoSize) {
            this.refs.drawingContainer.style.maxWidth = width + "px";
            this.refs.drawingContainer.style.maxHeight = height + "px";
        }
        if (this.imageType === 'image') {
            width = this.refs.backgroundImage.naturalWidth;
            height = this.refs.backgroundImage.naturalHeight;
        }
        return { minX: 0, minY: 0, width: width, height: height };
    };
    Sketchpad.prototype.onBackgroundImageWasSetted = function () {
        this.loadRefs(this.element, {
            backgroundImage: 'single',
            component: 'single',
        });
        var _a = this.viewBoxFromSubmission || this.calculateCanvasViewBox(), width = _a.width, height = _a.height, minX = _a.minX, minY = _a.minY;
        this.setCanvasViewBox(width, height, minX, minY);
        this.draw(this.dataValue);
        this.backgroundReady.resolve();
    };
    /**
     * Calculates the width and height that image should have to make the component fit the window's size
     */
    Sketchpad.prototype.calculateAutoSize = function () {
        var _a;
        var width = Math.round((_a = this.refs.drawingContainer) === null || _a === void 0 ? void 0 : _a.offsetWidth);
        var currentWidth = this.dimensions.width;
        var currentHeight = this.dimensions.height;
        // Calculate the ratio between image's width and height
        var ratio = currentWidth / currentHeight;
        // Calculate the image's height based on the available width
        var height = Math.round(width / ratio);
        // Calculate the maximal height of the image based on the window's height
        var availableHeight = Math.round(window.innerHeight - window.innerHeight * 0.2);
        // If the available height is geater than the height calculated based on the available width
        if (availableHeight < height || width === 0) {
            // Set it to the available and recalculate the width
            height = availableHeight;
            width = Math.round(height * ratio);
        }
        return { width: width, height: height };
    };
    Sketchpad.prototype.setOpenModalElement = function () {
        var template = "\n      " + this.componentLabel + "\n      <div class=\"formio-sketchpad-modal-preview-container\" ref=\"previewContainer\">\n        <div ref=\"openModal\">\n          <img\n            class=\"formio-sketchpad-modal-preview-background\"\n            ref=\"previewBackground\"\n            src=\"" + this.component.imageUrl + "\"\n            width=\"100%\"\n            alt=\"sketchpad preview background\"\n          />\n        </div>\n      </div>\n    ";
        this.componentModal.setOpenModalElement(template);
    };
    Sketchpad.prototype.getPreviewImage = function () {
        if (!this.canvasSvg || !this.two || !this.zoomInfo.viewBox.default) {
            return '';
        }
        else {
            return "<img class=\"formio-sketchpad-modal-preview-drawing\" src=\"data:image/svg+xml;base64," + this.getEncodedDrawing() + "\"\n                ref=\"previewDrawing\" width=\"100%\" alt=\"sketchpad preview drawing\"/>";
        }
    };
    Sketchpad.prototype.getValueAsString = function (value, options) {
        if (!value || !value.length) {
            return '';
        }
        ;
        if (options === null || options === void 0 ? void 0 : options.email) {
            return ("\n        <table border=\"1\" style=\"width:100%\">\n          <thead>\n            <tr><th>" + this.component.label + "</th>[Complex Data]</tr>\n          </thead>\n        <tbody>\n      ");
        }
        return '[Complex Data]';
    };
    Sketchpad.prototype.getEncodedDrawing = function () {
        var svgElement = this.getSvg();
        var svg = new XMLSerializer().serializeToString(svgElement);
        var encoded = window.btoa(svg);
        return encoded;
    };
    Sketchpad.prototype.getModalPreviewTemplate = function () {
        var template = "\n      " + this.componentLabel + "\n      <div class='formio-sketchpad-modal-preview-container' ref='previewContainer'>\n        <div ref=\"openModal\">\n          <img\n            ref=\"previewBackground\"\n            class='formio-sketchpad-modal-preview-background'\n            src=" + this.component.imageUrl + "\n            width=\"100%\"\n            alt=\"sketchpad preview background\"\n          />\n          " + this.getPreviewImage() + "\n        </div>\n      </div>";
        return template;
    };
    Sketchpad.prototype.mapDimensionsFromAttributes = function (svg) {
        return [
            { attribute: 'x', defaultValue: 0 },
            { attribute: 'y', defaultValue: 0 },
            { attribute: 'width', defaultValue: 640 },
            { attribute: 'height', defaultValue: 480 },
        ].map(function (dimension) {
            return parseFloat(svg.getAttribute(dimension.attribute)) || dimension.defaultValue;
        });
    };
    Sketchpad.prototype.setDimensions = function (viewBoxMinX, viewBoxMinY, viewBoxWidth, viewBoxHeight) {
        this.dimensions = {
            width: viewBoxWidth,
            height: viewBoxHeight,
            minX: viewBoxMinX,
            minY: viewBoxMinY,
        };
    };
    Sketchpad.prototype.stretchDrawingArea = function () {
        var _a = this.calculateAutoSize(), width = _a.width, height = _a.height;
        // don't stretch if background dimensions are unknown yet
        if (width && height) {
            var _b = this.zoomInfo, canvasViewBox = _b.canvasViewBox, totalMultiplier = _b.totalMultiplier;
            var defaultWidth = canvasViewBox.default.width;
            var defaultHeight = canvasViewBox.default.height;
            this.dimensionsMultiplier = width / defaultWidth;
            this.dimensions.width = Math.round(defaultWidth * this.dimensionsMultiplier);
            this.dimensions.height = Math.round(defaultHeight * this.dimensionsMultiplier);
            if (width === this.editorSize.width && height === this.editorSize.height) {
                return;
            }
            var editorWidth = totalMultiplier > 1 ? this.dimensions.width : this.dimensions.width * totalMultiplier;
            var editorHeight = totalMultiplier > 1 ? this.dimensions.height : this.dimensions.height * totalMultiplier;
            this.setEditorSize(editorWidth, editorHeight);
        }
    };
    Sketchpad.prototype.setEditorSize = function (width, height) {
        if (this.two) {
            this.editorSize = ({ width: width, height: height });
            this.two.width = width;
            this.two.height = height;
            this.two.update();
        }
        if (this.refs.backgroundImage) {
            this.refs.backgroundImage.setAttribute('width', width);
            this.refs.backgroundImage.setAttribute('height', height);
        }
        if (this.canvasSvg) {
            this.canvasSvg.style.width = width;
            this.canvasSvg.style.height = height;
        }
    };
    Sketchpad.prototype.clear = function () {
        if (this.two) {
            this.two.clear();
        }
    };
    Sketchpad.prototype.clearAll = function () {
        this.layers = [];
        this.dataValue = [];
        if (this.two) {
            this.clear();
            this.two.update();
        }
    };
    Sketchpad.prototype.draw = function (value) {
        var _this = this;
        if (!this.two) {
            return;
        }
        this.clear();
        if (!value || !value.length) {
            this.two.update();
            return;
        }
        this.layers = value.map(function (item) { return _this.modes[item.mode].draw(item); });
        this.two.update();
        this.appendDrawingToPreview();
    };
    Sketchpad.prototype.appendDrawingToPreview = function () {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            var drawingData, combinedBackgroundAndDrawing, drawing, _e;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        if (!((_a = this.componentModal) === null || _a === void 0 ? void 0 : _a.element)) return [3 /*break*/, 6];
                        this.loadComponentRefs(this.componentModal.element);
                        drawingData = "data:image/svg+xml;base64," + this.getEncodedDrawing();
                        combinedBackgroundAndDrawing = void 0;
                        if (!this.refs.previewDrawing) return [3 /*break*/, 3];
                        (_b = this.refs.previewDrawing) === null || _b === void 0 ? void 0 : _b.setAttribute('src', drawingData);
                        if (!(((_c = this.refs.previewBackground) === null || _c === void 0 ? void 0 : _c.height) > 0)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.combineIntoSingleImage(this.refs.previewBackground, this.refs.previewDrawing, this.imageType)];
                    case 1:
                        combinedBackgroundAndDrawing = _f.sent();
                        (_d = this.refs.previewDrawing) === null || _d === void 0 ? void 0 : _d.setAttribute('src', combinedBackgroundAndDrawing);
                        _f.label = 2;
                    case 2: return [3 /*break*/, 6];
                    case 3:
                        drawing = new Image();
                        drawing.src = drawingData;
                        this.addClass(drawing, 'formio-sketchpad-modal-preview-drawing');
                        drawing.setAttribute('ref', 'previewDrawing');
                        if (!!navigator.userAgent.includes('Firefox')) return [3 /*break*/, 5];
                        combinedBackgroundAndDrawing = this.combineIntoSingleImage(this.refs.previewBackground, drawing, this.imageType);
                        _e = drawing;
                        return [4 /*yield*/, combinedBackgroundAndDrawing];
                    case 4:
                        _e.src = _f.sent();
                        _f.label = 5;
                    case 5:
                        if (this.refs.previewContainer) {
                            this.refs.previewContainer.appendChild(drawing);
                            this.addEventListener(drawing, 'click', this.componentModal.openModalListener);
                        }
                        _f.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    Sketchpad.prototype.combineIntoSingleImage = function (background, drawing, imageType) {
        var _this = this;
        var promise = new Promise(function (resolve) {
            var canvas = document.createElement('canvas');
            var naturalWidth = background.naturalWidth, backgroundWidth = background.width, naturalHeight = background.naturalHeight, backgroundHeight = background.height;
            var width = naturalWidth || backgroundWidth;
            var height = naturalHeight || backgroundHeight;
            canvas.width = width;
            canvas.height = height;
            var context = canvas.getContext('2d');
            context.rect(0, 0, canvas.width, canvas.height);
            if (imageType !== 'image') {
                background.crossOrigin = 'anonymous';
            }
            drawing.crossOrigin = 'anonymous';
            drawing.width = width;
            drawing.height = height;
            var layers = [background, drawing];
            var counter = layers.length;
            background.onload = drawing.onload = function () {
                counter--;
                if (counter === 0) {
                    if (_this.options.pdf) {
                        background.style.display = 'none';
                        drawing.style.position = 'relative';
                    }
                    context.drawImage(background, 0, 0, width, height);
                    context.drawImage(drawing, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/png', 1.0));
                }
            };
        });
        return promise;
    };
    Sketchpad.prototype.undo = function () {
        var value = this.dataValue.slice();
        if (!value.length) {
            return;
        }
        this.deleted.push(value.pop());
        this.dataValue = value;
        this.triggerChange();
        this.draw(value);
    };
    Sketchpad.prototype.redo = function () {
        if (!this.deleted.length) {
            return;
        }
        var value = this.dataValue.slice();
        value.push(this.deleted.pop());
        this.dataValue = value;
        this.triggerChange();
        this.draw(value);
    };
    Sketchpad.prototype.setValue = function (value, flags) {
        var _a;
        _super.prototype.setValue.call(this, value, flags);
        var valueViewBox = (_a = value === null || value === void 0 ? void 0 : value[0]) === null || _a === void 0 ? void 0 : _a.viewBox;
        if (valueViewBox) {
            this.viewBoxFromSubmission = valueViewBox;
        }
        if (!this.backgroundReady.isReady || !this.two) {
            return;
        }
        this.draw(value);
    };
    Sketchpad.prototype.getSvg = function () {
        // clone view SVG element from editor
        var svgElement = this.canvasSvg.cloneNode(true);
        this.addClass(svgElement, 'formio-sketchpad-preview-svg');
        svgElement.removeAttribute('style');
        // set viewBox to default to reset zoom
        var defaultViewBox = this.zoomInfo.canvasViewBox.default;
        this.setViewBoxAttribute(svgElement, defaultViewBox);
        return svgElement;
    };
    Sketchpad.prototype.normalizeSvgOffset = function (type) {
        if (type === void 0) { type = 'viewBox'; }
        var viewBox = this.zoomInfo[type];
        // don't let offset go out of SVG on the left and on the top
        this.zoomInfo[type].current.minX = viewBox.current.minX < viewBox.default.minX ? viewBox.default.minX
            : viewBox.current.minX;
        this.zoomInfo[type].current.minY = viewBox.current.minY < viewBox.default.minY ? viewBox.default.minY
            : viewBox.current.minY;
        // don't let offset go out of SVG on the right and on the bottom
        var canvasMaxOffsetX = viewBox.default.width - viewBox.current.width + viewBox.default.minX;
        var canvasMaxOffsetY = viewBox.default.height - viewBox.current.height + viewBox.default.minY;
        this.zoomInfo[type].current.minX = viewBox.current.minX > (canvasMaxOffsetX) ? canvasMaxOffsetX
            : viewBox.current.minX;
        this.zoomInfo[type].current.minY = viewBox.current.minY > (canvasMaxOffsetY) ? canvasMaxOffsetY
            : viewBox.current.minY;
    };
    Sketchpad.prototype.setViewBoxAttribute = function (element, viewBox) {
        element.setAttribute('viewBox', viewBox.minX + " " + viewBox.minY + " " + viewBox.width + " " + viewBox.height);
    };
    Sketchpad.prototype.updateSvgViewBox = function (type) {
        if (type === void 0) { type = 'viewBox'; }
        // set viewBox so that SVG gets zoomed to the proper area according to zoomInfo
        var viewBox = this.zoomInfo[type].current;
        if (this.imageType !== 'svg') {
            return;
        }
        if (type === 'viewBox') {
            this.setViewBoxAttribute(this.refs.backgroundImage, viewBox);
        }
        else {
            this.setViewBoxAttribute(this.canvasSvg, viewBox);
        }
    };
    Sketchpad.prototype.drag = function (offset, type) {
        if (type === void 0) { type = 'viewBox'; }
        // calculate new offsets for SVG
        this.zoomInfo[type].current.minX = this.zoomInfo[type].current.minX - offset.x;
        this.zoomInfo[type].current.minY = this.zoomInfo[type].current.minY - offset.y;
        this.normalizeSvgOffset(type);
        this.updateSvgViewBox(type);
    };
    Sketchpad.prototype.dragImage = function (offset) {
        if (this.imageType !== 'svg') {
            var clientWidth = this.refs.drawingContainer.clientWidth;
            var clientHeight = this.refs.drawingContainer.clientHeight;
            var scrollHeight = this.refs.drawingContainer.scrollHeight;
            var scrollWidth = this.refs.drawingContainer.scrollWidth;
            var scrollLeft = this.refs.drawingContainer.scrollLeft;
            var scrollTop = this.refs.drawingContainer.scrollTop;
            this.refs.drawingContainer.scrollTop = Math.min(scrollHeight - clientHeight, scrollTop + offset.y);
            this.refs.drawingContainer.scrollLeft = Math.min(scrollWidth - clientWidth, scrollLeft + offset.x);
            return;
        }
        var correctedOffset = this.dimensionsCorrection ? {
            x: offset.x / this.dimensionsCorrection,
            y: offset.y / this.dimensionsCorrection
        } : offset;
        this.drag(correctedOffset);
        this.drag(offset, 'canvasViewBox');
    };
    Sketchpad.prototype.setTotalMultiplier = function (multiplier) {
        this.zoomInfo.totalMultiplier = multiplier;
        this.refs.totalMultiplier.innerHTML = this.t(Math.round(multiplier * 100) / 100);
    };
    Sketchpad.prototype.zoomImage = function (coordinate, type) {
        if (type === void 0) { type = 'viewBox'; }
        // calculate new viewBox width for canvas
        this.zoomInfo[type].current.width =
            Math.round(this.zoomInfo[type].default.width / this.zoomInfo.totalMultiplier);
        this.zoomInfo[type].current.height =
            Math.round(this.zoomInfo[type].default.height / this.zoomInfo.totalMultiplier);
        var _a = this.zoomInfo[type].current, currentWidth = _a.width, currentHeight = _a.height;
        var _b = this.zoomInfo[type].default, defaultWidth = _b.width, defaultHeight = _b.height;
        if (currentWidth > defaultWidth && currentHeight > defaultHeight) {
            this.zoomOut(type); // if should get less than initial size, change editor size instead of viewBox size
        }
        else {
            this.zoomIn(coordinate, type); // if should get more than initial size, change viewBox size
        }
        this.updateSvgViewBox(type);
    };
    Sketchpad.prototype.zoom = function (coordinate, multiplier) {
        this.setTotalMultiplier(this.zoomInfo.totalMultiplier * multiplier);
        var correctedCoordinate = this.dimensionsCorrection ? {
            x: coordinate.x / this.dimensionsCorrection,
            y: coordinate.y / this.dimensionsCorrection
        } : coordinate;
        this.zoomImage(correctedCoordinate);
        this.zoomImage(coordinate, 'canvasViewBox');
    };
    Sketchpad.prototype.zoomOut = function (type) {
        if (type === void 0) { type = 'viewBox'; }
        this.setEditorSize(this.dimensions.width * this.zoomInfo.totalMultiplier, this.dimensions.height * this.zoomInfo.totalMultiplier);
        // restore default viewBox values for canvas and background
        this.zoomInfo[type].current = Utils._.cloneDeep(this.zoomInfo[type].default);
    };
    Sketchpad.prototype.zoomIn = function (coordinate, type) {
        if (type === void 0) { type = 'viewBox'; }
        // restore editor size if needed
        if (this.canvasSvg.width !== this.dimensions.width || this.canvasSvg.height !== this.dimensions.height) {
            this.setEditorSize(this.dimensions.width, this.dimensions.height);
        }
        // if backgound is simple image change the editor's size
        if (this.imageType !== 'svg') {
            if (this.refs.backgroundImage) {
                this.setEditorSize(this.dimensions.width * this.zoomInfo.totalMultiplier, this.dimensions.height * this.zoomInfo.totalMultiplier);
            }
        }
        else {
            this.zoomInfo[type].current.minX = coordinate.x - this.zoomInfo[type].current.width / 2;
            this.zoomInfo[type].current.minY = coordinate.y - this.zoomInfo[type].current.height / 2;
        }
        this.normalizeSvgOffset(type);
    };
    Sketchpad.prototype.resetZoom = function () {
        this.zoom({ x: 0, y: 0 }, (this.component.defaultZoom / 100) / this.zoomInfo.totalMultiplier);
    };
    Sketchpad.editForm = editForm;
    return Sketchpad;
}(FieldComponent));
export default Sketchpad;
